/* gawkmisc.c --- miscellaneous gawk routines that are OS specific. -*-C-*- */

/* 
 * Copyright (C) 1986, 1988, 1989, 1991 - 2003, 2012, 2016, 2017
 * the Free Software Foundation, Inc.
 * 
 * This file is part of GAWK, the GNU implementation of the
 * AWK Progamming Language.
 * 
 * GAWK is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 * 
 * GAWK is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

char quote = '\'';
char envsep = ';';

# ifdef DEFPATH
const char *defpath = DEFPATH;
# else
const char *defpath = ".;c:\\lib\\awk;c:\\gnu\\lib\\awk";
# endif
/* the Makefile should define DEFLIBPATH */
const char *deflibpath = DEFLIBPATH;

#ifdef __EMX__
#include<io.h>

static int _os2_is_abs_path(const char *dirname);
static char* _os2_unixroot(const char *path);
static const char* _os2_unixroot_path(const char *path);
#endif /* __EMX__ */

#if defined(__MINGW32__) || defined(_MSC_VER)
#ifdef HAVE_SOCKETS
#include <socket.h>

#undef socket
#undef setsockopt
#undef bind
#undef connect
#undef listen
#undef accept
#undef recvfrom
#undef shutdown
#endif /* HAVE_SOCKETS */

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#endif /* __MINGW32__ || _MSC_VER */

#if ! defined(S_ISREG) && defined(S_IFREG)
#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
#endif

#if ! defined(S_ISDIR) && defined(S_IFDIR)
#define	S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#endif

#ifdef _MSC_VER
/* S_IFSOCK is non-standard for _MSC_VER.  */
#if ! defined(S_IFSOCK)
#define S_IFSOCK (S_IFREG | S_IFDIR)
#endif
#endif /* _MSC_VER */

#if ! defined(S_IFIFO) && defined(_S_IFIFO)
#define S_IFIFO _S_IFIFO
#endif

/* gawk_name --- pull out the "gawk" part from how the OS called us */

const char *
gawk_name(const char *filespec)
{
	char *p, *q;

	p = (char *) filespec;  /* Sloppy... */

	/* OS/2 allows / for directory separator too */
	if ((q = strrchr(p, '\\')) != NULL)
		p = q + 1;
	if ((q = strrchr(p, '/')) != NULL
	    && (p == NULL || q > p)) /* support mixed d:\foo/bar\gawk.exe */
		p = q + 1;
	if ((q = strchr(p, '.')) != NULL)
		*q = '\0';
	return strlwr(p);
}


#ifdef HAVE_MEMCPY_ULONG

/*
 * memcpy_long() & memset_ulong() are 32-bit replacements for MSC which
 * has a 16-bit size_t.
 */
char *
memcpy_ulong (dest, src, l)
register char *dest;
register const char *src;
register unsigned long l;
{
	register char *ret = dest;

	while (l--)
		*dest++ = *src++;

	return ret;
}

#endif /* HAVE_MEMCPY_ULONG */


#ifdef HAVE_MEMSET_ULONG

void *
memset_ulong(dest, val, l)
void *dest;
register int val;
register unsigned long l;
{
	register char *ret = dest;
	register char *d = dest;

	while (l--)
		*d++ = val;

	return ((void *) ret);
}

#endif /* HAVE_MEMSET_ULONG */


/* os_arg_fixup --- fixup the command line */

void
os_arg_fixup(int *argcp, char ***argvp)
{
#ifdef __EMX__
# ifdef initialize_main
	initialize_main(argcp, argvp);
# else
	_wildcard(argcp, argvp);
	_response(argcp, argvp);
# endif

	setvbuf(stdout, NULL, _IOLBF, BUFSIZ);
	defpath = _os2_unixroot_path(defpath);
#endif /* __EMX__ */
	(void) argcp, (void) argvp;
	return;
}

/* os_devopen --- open special per-OS devices */

fd_t
os_devopen(const char *name, int flag)
{
#ifdef __EMX__
	/* do not use open(name, flag) here !!! */
	return -1;
#else
	if (strcmp(name, "/dev/null") == 0)
		return open("NUL", flag);
	/* FIXME: */
	/* else if (strcmp(name, "/dev/tty") == 0)
	 * 	return open("???", flag);
	 */
	return -1;
#endif
}

/* optimal_bufsize --- determine optimal buffer size */

size_t
optimal_bufsize(fd_t fd, gawk_xstat_t *stb)
{
	/* force all members to zero in case OS doesn't use all of them. */
	memset(stb, '\0', sizeof(*stb));

	/*
	 * DOS doesn't have the file system block size in the
	 * stat structure. So we have to make some sort of reasonable
	 * guess. We use stdio's BUFSIZ, since that is what it was
	 * meant for in the first place.
	 */
#define	DEFBLKSIZE	BUFSIZ

	if (os_xfstat(fd, stb) == -1)
		fatal("can't stat fd %d (%s)", fd, strerror(errno));
	if (S_ISREG(stb->st_mode)
	    && 0 < stb->st_size && stb->st_size < DEFBLKSIZE) /* small file */
		return (size_t) stb->st_size;
	return DEFBLKSIZE;
}

/* ispath --- return true if path has directory components */

bool
ispath(const char *file)
{
#ifdef __EMX__
	return (strpbrk(file, "/\\") != NULL ||
		(toupper(file[0]) >= 'A' && toupper(file[0]) <= 'Z' && file[1] == ':'));
#else
	for (; *file; file++) {
		switch (*file) {
		case '/':
		case '\\':
		case ':':
			return true;
		}
	}
	return false;
#endif
}

/* isdirpunct --- return true if char is a directory separator */

bool
isdirpunct(int c)
{
	return (strchr(":\\/", c) != NULL);
}

/* os_close_on_exec --- set close on exec flag, print warning if fails */

void
os_close_on_exec(fd_t fd, const char *name, const char *what, const char *dir)
{
#if (defined(__DJGPP__) && (__DJGPP__ > 2 || __DJGPP_MINOR__ >= 4)) || defined __EMX__
	if (fd <= 2)	/* sanity */
		return;

	if (fcntl(fd, F_SETFD, 1) < 0)
		warning("%s %s `%s': could not set close-on-exec: %s",
			what, dir, name, strerror(errno));
#endif
#if defined(__MINGW32__) || defined(_MSC_VER)
	HANDLE fh;
#ifdef _MSC_VER
	SOCKET s = valid_socket (fd);
	if (s != INVALID_SOCKET)
		fh = (HANDLE)s;
	else
#endif
		fh = (HANDLE)_get_osfhandle(fd);
	if (fh != INVALID_HANDLE_VALUE)
		SetHandleInformation(fh, HANDLE_FLAG_INHERIT, 0);
#endif
	(void) name, (void) what, (void) dir;
}

/* os_isdir --- is this an fd on a directory? */

bool
os_isdir(fd_t fd)
{
	gawk_stat_t sbuf;

	return (os_fstat(fd, &sbuf) == 0 && S_ISDIR(sbuf.st_mode));
}

/* os_isreadable --- fd can be read from */

bool
os_isreadable(const awk_input_buf_t *iobuf, bool *isdir)
{
	*isdir = false;

	switch (iobuf->sbuf.st_mode & S_IFMT) {
	case S_IFREG:
	case S_IFCHR:	/* ttys, /dev/null, .. */
#ifdef S_IFSOCK
	case S_IFSOCK:
#endif
#ifdef S_IFIFO
	case S_IFIFO:
#endif
		return true;
	case S_IFDIR:
		*isdir = true;
		/* fall through */
	default:
		return false;
	}
}

/* os_is_setuid --- true if running setuid root */

bool
os_is_setuid(void)
{
#ifdef __EMX__
      	long uid, euid;

	uid = getuid();
	euid = geteuid();

	return (euid == 0 && euid != uid);
#else
	return false;
#endif
}

/* os_setbinmode --- set binary mode on file */

#ifdef __DJGPP__
#include <sys/exceptn.h>
#include <io.h>
#endif
static int orig_tty_mode = -1;

int
os_setbinmode(fd_t fd, int mode)
{
	int prev_mode;

#ifdef _MSC_VER
	if (is_socket(fd)) {
		/* Only O_BINARY mode is supported.  */
		assert(mode == O_BINARY);
		return O_BINARY;
	}
#endif

	prev_mode = setmode(fd, mode);

#ifdef __DJGPP__
	if ((mode & O_BINARY) != 0)
		__djgpp_set_ctrl_c(1); /* allow to interrupt with Ctrl-C */
#endif
	/* Save the original tty mode as we found it.  */
	if (orig_tty_mode == -1 && fd >= 0 && fd <= 2)
		orig_tty_mode = prev_mode;
	return prev_mode;
}

/* os_restore_mode --- restore the original mode of the console device */

void
os_restore_mode(fd_t fd)
{
#ifdef _MSC_VER
	if (is_socket(fd))
		return;
#endif
	if (orig_tty_mode != -1)
		(void) setmode(fd, orig_tty_mode);
}

/* os_isatty --- return true if fd is a tty */

bool
os_isatty(fd_t fd)
{
#ifdef _MSC_VER
	if (is_socket(fd))
		return false;
#endif
#if defined(__MINGW32__) || defined(_MSC_VER)
	return (isatty(fd) && lseek(fd, SEEK_CUR, 0) == -1);
#else
	return isatty(fd);
#endif
}

/* files_are_same --- return true if files are identical */

bool
files_are_same(const char *path, SRCFILE *src)
{
	size_t pathlen;
	const char *p, *s;

#ifdef _MSC_VER
	struct xstat st;
	int r = xstat (path, & st);
#else
	struct stat st;
	int r = stat (path, & st);
#endif

	if (r != 0)
		return false;

	/* If they have a working `stat', honor that.  */
	if (!(st.st_dev == src->sbuf.st_dev
	      && st.st_ino == src->sbuf.st_ino))
		return false;

	/* Compare modification times.  */
	if (st.st_mtime != src->mtime)
		return false;

	/* Compare absolute file names case-insensitively, and
	   treat forward- and back-slashes as equal.  */
	pathlen = strlen(path);
	for (p = path, s = src->fullpath;
	     p <= path + pathlen;
	     p++, s++) {
		if (tolower((unsigned char)*p) != tolower((unsigned char)*s)
		    && !((*p == '/' || *p == '\\')
			 && (*s == '/' || *s == '\\')))
			return false;
	}
	return true;
}


#ifdef __EMX__ 
# ifndef PATH_SEPARATOR
#  define PATH_SEPARATOR ';'
# endif

/* result is 0 if dirname is no absolute path, 1 otherwise */

static int
_os2_is_abs_path(const char *dirname)
{
  int result = 0;
  if (dirname != NULL && dirname[0] != '\0') {
    /* if dirname contains a valid drive letter like "c:" */
    if (((dirname[0] >= 'A' && dirname[0] <= 'Z') || (dirname[0] >= 'a' && dirname[0] <= 'z'))
        && dirname[1] == ':') dirname += 2; /* remove the drive letter */

    if (dirname[0] == '/' || dirname[0] == '\\') result = 1; /* asbolute path */
  }

  return result;
}


/* path is assumed to be a list of directories separated by PATH_SEPARATOR.
   This function determines if the first directory of path is on the
   drive specified by the environment variable UNIXROOT.
   If it is the case, NULL is returned, otherwise a new directory name
   is allocated using the drive letter from UNIXROOT and returned as result.
   If the first directory is a relative path NULL is returned, too.
   The new directory name is allocated by malloc().
   Example (UNIXROOT is set to "e:"):
     "c:/usr/share" -> "e:/usr/share"
     "e:/usr/share" -> NULL             (already on the $UNIXROOT drive)
     "/usr/share"   -> "e:/usr/share"
     "."            -> NULL             (not an absolute path)
     "usr/share"    -> NULL             (not an absolute path)
     "c:usr/share"  -> NULL             (not an absolute path)
     "c:/usr/share;d:/etc" -> "e:/usr/share" (only the first directory in path is used) */

static char*
_os2_unixroot(const char *path)
{
  static const char *unixroot = NULL;
  static int unixroot_init = 0; 
  char *result = NULL; 

  if (unixroot_init == 0) {
    /* get $UNIXROOT only one time */
    unixroot = getenv("UNIXROOT");

    /* check whether unixroot is valid (must be "x:") */
    if (unixroot != NULL) {
      int drive = toupper(unixroot[0]);
      if (drive < 'A' || drive > 'Z' || unixroot[1] != ':' || unixroot[2] != '\0')
        unixroot = NULL; /* unixroot not valid */
    }

    unixroot_init = 1; /* initialized */
  }

  /* note: if unixroot != NULL then it contains a valid drive letter */
  if (unixroot != NULL && _os2_is_abs_path(path)) {
    /* dirname is an absolute path and unixroot is a drive letter, "c:" for example */
    size_t old_path_len = strlen(path);

    /* end points to the first ';' in path or to NULL */
    const char *end = strchr(path, PATH_SEPARATOR);

    /* dir_len is the length of the first directory in path */
    size_t dir_len = (end) ? end - path : old_path_len;

    if (toupper(unixroot[0]) != toupper(path[0]) || path[1] != ':') {
      /* the first directory of path does not start with the string $UNIXROOT */
      if (path[1] == ':') {
        /* if there is a drive letter remove it */
        dir_len -= 2;
        path += 2;
      } 

      result = malloc(dir_len + 3);
      if (result) { /* do nothing if we are out of memory */
        result[0] = unixroot[0];
        result[1] = unixroot[1];
        memcpy(result + 2, path, dir_len);
        result[dir_len + 2] = '\0';
      }
    }
  }
  return result;
}

/* path is assumed to be a list of directories separated by PATH_SEPARATOR.
   Every directory is processed. _os2_unixroot() is used to find out whether
   these directories are on the drive specified by the environment variable
   UNIXROOT. If this is not the case the same directory on the UNIXROOT drive
   is added to the end of path. If path is a valid path this function returns a valid path, too.
   Example ($UNIXROOT is set to "e:"):
   ".;c:/usr/local;d:/usr/local;d:/etc;e:/etc"
   -> ".;c:/usr/local;d:/usr/local;d:/etc;e:/etc;e:/usr/local;e:/usr/local;e:/etc" */

static const char*
_os2_unixroot_path(const char *path)
{
  char *result = NULL;
  const char *p = path;
  unsigned dir_count = 1;

  if (path == NULL || path[0] == '\0') return NULL; /* empty path */

  /* save number of path components in dir_count */
  while(*p) {
    if (*p++ == PATH_SEPARATOR && *p != '\0' && *p != PATH_SEPARATOR)
      dir_count += 1;
  }

  {
    const char *list[dir_count]; /* list of char pointers */
    size_t dir_len[dir_count]; /* the according directory length */
    size_t old_path_len = strlen(path); /* the old path length */
    size_t total_len;
    unsigned i = 0;

    if (path[old_path_len - 1] == PATH_SEPARATOR) /* last character is ';' */
      old_path_len--;

    list[0] = p = path; /* first directory */

    while(*p) {
    if (*p++ == PATH_SEPARATOR && *p != '\0' && *p != PATH_SEPARATOR)
      list[++i] = p;
    }
    /* now list[i] contains the ith directory of path (no 0-terminated strings!!!) */

    /* determine the total length for the new path */
    total_len = old_path_len;

    for(i = 0; i < dir_count; i++) {
      list[i] = _os2_unixroot(list[i]);
      if (list[i] != NULL) {
        dir_len[i] = strlen(list[i]);
        total_len += dir_len[i] + 1; /* one character for ';' or '\0' */
      }
      else dir_len[i] = 0;
    }
    /* now list[] contains the according directories on the UNIXROOT drive or NULL
       total_len contains the total length for the new path */
    result = malloc(total_len + 1);

    if (result) {
      /* copy the old path and the new directories into the new path */
      char *q = result;
      memcpy(q, path, old_path_len);
      q += old_path_len;

      for(i = 0; i < dir_count; i++) {
        if (dir_len[i] != 0) {
          *q++ = PATH_SEPARATOR;
          memcpy(q, list[i], dir_len[i]);
          q += dir_len[i];
        }
      }

      *q = '\0'; /* terminating '\0' */
    }

    for(i = 0; i < dir_count; i++) free((void*) list[i]);
  }

  return (result) ? (const char*) result : path;
}

/* limit a length of DLL name up to 8 characters. If dst is not enough for
   a fixed dll name, it is truncated. */
char *os2_fixdllname(char *dst, const char *src, size_t n)
{
    char drive[_MAX_DRIVE];
    char dir[_MAX_DIR];
    char name[_MAX_FNAME];
    char ext[_MAX_EXT];
    char dll_file[_MAX_PATH];

    _splitpath(src, drive, dir, name, ext);
    if (strlen(name) > 8)
        name[8] = '\0';
    _makepath(dll_file, drive, dir, name, ext);

    strncpy(dst, dll_file, n);
    dst[n - 1] = '\0';

    return dst;
}

#ifdef __KLIBC__

/* replacement of dlopen(). This limits a length of a base name up to 8
   characters. */
void *os2_dlopen(const char *file, int mode)
{
    char dll_file[strlen(file) + 1];

    return (dlopen)(os2_fixdllname(dll_file, file, sizeof(dll_file)), mode);
}

/* replacement of dlsym(). This prepends '_' to name. */
void *os2_dlsym(void *handle, const char *name)
{
    char sym[strlen(name) + 1 + 1]; /* 1 for '_', 1 for NUL */

    sym[0] = '_';
    strcpy(sym + 1, name);

    return (dlsym)(handle, sym);
}

#endif /* __KLIBC__ */

#endif /* __EMX__ */

#if defined(__MINGW32__) || defined(_MSC_VER)

int
setenv (const char *name, const char *value, int rewrite)
{
  char *entry;

  if (*value == '=')
    ++value;

  if (getenv (name) && !rewrite)
    return 0;

  emalloc(entry, char *, strlen (name) + 1 + strlen (value) + 1, "setenv");
  strcat (strcat (strcpy (entry, name), "="), value);
  if (putenv (entry) != 0)
    {
      free (entry);
      return -1;
    }
  return 0;
}

int
unsetenv (const char *name)
{
  if (!name || !*name || strchr (name, '=') != NULL)
    return -1;

  return setenv (name, "", 1);
}

/* MinGW 3.21 and later defines usleep as an inline function in
   unistd.h, which conflicts with the version below.  */
#if defined(_MSC_VER) || (__MINGW32_MAJOR_VERSION + (__MINGW32_MINOR_VERSION > 20) < 4)
int
usleep(unsigned int usec)
{
  double msecf = usec / 1000.0;

  Sleep ((DWORD)msecf);

  return usec - msecf * 1000 < 0 ? 0 : (int)(usec - msecf * 1000);
}
#endif


#ifndef _MSC_VER

/* The implementation of wctob in the MS runtime is problematic
   because it doesn't allow to distinguish between WEOF and 0xff, due
   to integer sign extension.  It also causes failures in dfa.c when
   characters with the 8th bit set are involved.  This replacement
   version fixes that.  */

#include <wchar.h>

int
wctob (wint_t wc)
{
  char buf[64];

  if (!(MB_CUR_MAX <= sizeof (buf)))
    abort ();
  /* Handle the case where WEOF is a value that does not fit in a wchar_t.  */
  if (wc == (wchar_t)wc)
    if (wctomb (buf, (wchar_t)wc) == 1)
      return (unsigned char) buf[0];
  return EOF;
}

#else /* _MSC_VER */

/* M.B. No problems with newer MS runtime - it typedefs both wint_t and wchar_t as
   unsigned short, e.g. in locale Russian_Russia.1251:
   wctob(WEOF) == -1, wctob(0xff) == 0x79.  */

/* 1) Check that wint_t do not sign-extends (like 'char' do) WEOF and 0xff */
typedef int ms_wint_t_check_1[1-2*((unsigned)0xff != (wint_t)0xff)];
typedef int ms_wint_t_check_2[1-2*((unsigned)WEOF != (wint_t)WEOF)];

/* 2) check that (wint_t)WEOF fits in wchar_t */
typedef int ms_wchar_t_check[1-2*((wint_t)WEOF != (wchar_t)WEOF)];

#endif /* _MSC_VER */


#undef setlocale
#include <locale.h>

#ifndef _MSC_VER

/* On Posix systems, 'setlocale' looks at LC_* variables in the
   environment, and Gawk users might expect that on Windows as well.
   The replacement implementation below does that, and also fixes a
   few additional quirks with locales on Windows.  */
static const char *
lc_var (int category)
{
  static const char *const loc_name[LC_MAX - LC_MIN + 1] = {
    "LC_ALL", "LC_COLLATE", "LC_CTYPE", "LC_MONETARY", "LC_NUMERIC", "LC_TIME"
  };

  /* This function assumes LC_* categories are small numbers between 0
     and 5, as shown above, so if that changes at some point, complain
     vociferously.  */
  if (LC_ALL != 0 || LC_CTYPE != 2 || LC_TIME != 5)
    abort ();
  /* Ensured by the caller, so should never happen.  */
  if (category < LC_MIN || category > LC_MAX)
    return "????";
  return loc_name[category];
}

char *
w32_setlocale (int category, const char *value)
{
  const char *new_locale = value;

  if (LC_MIN <= category && category <= LC_MAX
      && value && *value == '\0')
    {
      const char *lc_val = getenv ("LC_ALL");

      if (!lc_val)
        lc_val = getenv (lc_var (category));
      if (!lc_val)
        lc_val = getenv ("LANG");
      if (lc_val)
        new_locale = lc_val;
    }

  /* If VALUE includes a codeset, i.e. a Windows codepage number, we
     must also set the LC_CTYPE locale to the same value, because
     LC_CTYPE is the only category which is documented to be able to
     change the codepage.  */
  if (category != LC_ALL && category != LC_CTYPE)
    {
      const char *p = strchr (new_locale, '.');

      if (p && isdigit (p[1]))
        setlocale (LC_CTYPE, new_locale);
    }
  return setlocale (category, new_locale);
}

#else /* _MSC_VER */

static void
set_lcat_from_env(int cat, const char name[])
{
	const char *lc = getenv(name);
	if (lc && lc[0] && !setlocale(cat, lc))
		fatal(_("Bad locale: %s=%s"), name, lc);
}

/* Set locale based on the values of environment variables.  */
/* M.B. Note: w32_setlocale defined above is buggy - it doesn't set e.g.
  LC_NUMERIC from the environment if called as w32_setlocale(LC_ALL, ""),
  if both LC_ALL and LANG are not defined in the environment.  */
void
set_locale_from_env(const char *def)
{
	const char *lc = getenv("LC_ALL");
	if (lc && lc[0]) {
		if (!setlocale(LC_ALL, lc))
			fatal(_("Bad locale: LC_ALL=%s"), lc);
		return;
	}

	/* LANG is the default for all LC_...  */
	lc = getenv("LANG");

	/* if LANG is not defined - set the system default.
	   (If def is "", locale may be be set to e.g. Russian_Russia.1251).  */
	if (!lc || !lc[0])
		lc = def;

	if (!setlocale(LC_ALL, lc))
		fatal(_("Bad locale: LANG=%s"), lc);

	/* set all locale categories from the environment:
	   specific LC_... take precedence over LANG.  */
	set_lcat_from_env(LC_CTYPE,    "LC_CTYPE");
	set_lcat_from_env(LC_COLLATE,  "LC_COLLATE");
	set_lcat_from_env(LC_MONETARY, "LC_MONETARY");
	set_lcat_from_env(LC_NUMERIC,  "LC_NUMERIC");
	set_lcat_from_env(LC_TIME,     "LC_TIME");
}

#endif /* _MSC_VER */

/* Replacement for the missing nl_langinfo.  Only CODESET is currently
   supported.  */
#include <langinfo.h>

const char *
nl_langinfo (int item)
{
  switch (item)
    {
      case CODESET:
        {
          /* M.B. Reworked Gnulib's implementation of nl_langinfo:
             - Gnulib's implementation is unnecessarily complex,
             - Gnulib's implementation doesn't handle UTF-8 code page.  */
          static char buf[2 + 10 + 1] = "CP";
          const char *locale = setlocale (LC_CTYPE, NULL);
          const char *codeset = "";
          const char *codeset_end = codeset;

          if (locale && locale[0])
            {
              /* If the locale name contains an encoding after the
                 dot, return it.  */
              const char *dot = strchr (locale, '.');

              if (dot)
                {
                  codeset = dot + 1;

                  /* Check if codeset is UTF8 */
                  if ((codeset[0] == 'u' || codeset[0] == 'U') &&
                      (codeset[1] == 't' || codeset[1] == 'T') &&
                      (codeset[2] == 'f' || codeset[2] == 'F') &&
                     ((codeset[3] == '8' && codeset[4] == '\0') ||
                      (codeset[3] == '-' && codeset[4] == '8' && codeset[5] == '\0')))
                    {
                      return "UTF-8";
                    }

                  /* Look for the possible @... trailer and remove it,
                     if any.  */
                  codeset_end = strchr (codeset, '@');
                  if (! codeset_end)
                    codeset_end = strchr (codeset, '\0');
                }
            }

          /* If setlocale is successful, it returns the number of the
             codepage, as a string.  Otherwise, fall back on Windows
             API GetACP, which returns the locale's codepage as a
             number (although this doesn't change according to what
             the 'setlocale' call specified).  Either way, prepend
             "CP" to make it a valid codeset name.  */
          {
            size_t codesetlen = (size_t) (codeset_end - codeset);
            if (0 < codesetlen && codesetlen < sizeof(buf) - 2)
              ((char*) memcpy (buf + 2, codeset, codesetlen))[codesetlen] = '\0';
            else
              sprintf (buf + 2, "%u", GetACP ());
          }

          return buf;
        }
      default:
        return "";
    }
}

#include <process.h> /* for _spawnvp */

/*
 * On MS-Windows with MinGW, execvp causes the shell and the re-exec'ed
 * dgawk to compete for the keyboard input.
 *
 * This will need work if we ever need a real version of execvp.
 */
int w32_execvp(const char *file, char **argv)
{
	if (_spawnvp(_P_WAIT, file, (const char * const *)argv) != -1)
		exit(EXIT_SUCCESS);

	return -1;
}

#ifdef DYNAMIC

#include <winerror.h>
#include <dlfcn.h>

static DWORD last_err;

void *
dlopen (const char *file, int mode)
{
  char dllfn[MAX_PATH], *p;
  HANDLE dllhandle;

  if (mode != RTLD_LAZY)
    {
      errno = EINVAL;
      last_err = ERROR_INVALID_PARAMETER;
      return NULL;
    }

  /* MSDN says to be sure to use backslashes in the DLL file name.  */
  strcpy (dllfn, file);
  for (p = dllfn; *p; p++)
    if (*p == '/')
      *p = '\\';

  dllhandle = LoadLibrary (dllfn);
  if (!dllhandle)
    last_err = GetLastError ();

  return dllhandle;
}

const char *
dlerror_buf (char buf[], unsigned int buf_size)
{
  DWORD ret;

  if (!last_err)
    return NULL;

  ret = FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM
		       | FORMAT_MESSAGE_IGNORE_INSERTS,
		       NULL, last_err, 0, buf, buf_size, NULL);
  while (ret > 0 && (buf[ret - 1] == '\n' || buf[ret - 1] == '\r'))
    --ret;

  buf[ret] = '\0';
  if (!ret)
    {
      (void) _snprintf (buf, buf_size, "Error code %lu", last_err);
      buf[buf_size - 1] = '\0';
    }

  last_err = 0;
  return buf;
}

int
dlclose (void *handle)
{
  if (!handle || handle == INVALID_HANDLE_VALUE)
    return -1;
  if (!FreeLibrary ((HMODULE)handle))
    return -1;

  return 0;
}

void *
dlsym (void *handle, const char *name)
{
  FARPROC addr = NULL;

  if (!handle || handle == INVALID_HANDLE_VALUE)
    {
      last_err = ERROR_INVALID_PARAMETER;
      return NULL;
    }

  addr = GetProcAddress ((HMODULE)handle, name);
  if (!addr)
    last_err = GetLastError ();

  return (void *)addr;
}
#endif	/* DYNAMIC */

#ifdef HAVE_SOCKETS

#ifdef _MSC_VER

#ifndef SOCKET_TAB_MAX_ROWS
#define SOCKET_TAB_MAX_ROWS  128
#endif

/* SOCKET_TAB_MAX_ROWS must be non-zero */
typedef int socket_tab_max_rows_is_zero_[1 - 2*!SOCKET_TAB_MAX_ROWS];

#ifndef SOCKET_ARRAY_SIZE
#define SOCKET_ARRAY_SIZE    64
#endif

/* SOCKET_ARRAY_SIZE must be non-zero */
typedef int socket_array_size_is_zero_[1 - 2*!SOCKET_ARRAY_SIZE];

/* SOCKET_ARRAY_SIZE must be power of the two */
typedef int socket_array_size_is_not_power_of_two_[1 -
  2*!!((SOCKET_ARRAY_SIZE - 1) & SOCKET_ARRAY_SIZE)];

typedef SOCKET socket_array_t[SOCKET_ARRAY_SIZE];
static socket_array_t **socket_tab = NULL;
static socket_array_t *socket_arr_cached = NULL;
static size_t socket_tab_size = 0;
static size_t socket_tab_capacity = 0;

static socket_array_t *new_socket_array(void)
{
  socket_array_t *arr = (socket_array_t*) malloc(sizeof(*arr));
  if (arr != NULL) {
    size_t j = 0;
    for (; j < SOCKET_ARRAY_SIZE; j++)
      (*arr)[j] = INVALID_SOCKET;
  }
  return arr;
}

static int alloc_socket_fd(void)
{
  /* find free cell */
  size_t i, j;
  for (i = 0; i < socket_tab_size; i++) {
    for (j = 0; j < SOCKET_ARRAY_SIZE; j++) {
      if ((*socket_tab[i])[j] == INVALID_SOCKET)
        return (int) (i*SOCKET_ARRAY_SIZE + j);
    }
  }

  /* no free cells */
  if (socket_tab_size == SOCKET_TAB_MAX_ROWS)
    return -1;

  /* add new row */
  if (socket_tab_size == socket_tab_capacity) {
    socket_array_t **new_tab = (socket_array_t**) realloc(
      socket_tab, sizeof(*socket_tab)*(socket_tab_capacity + 1));
    if (new_tab == NULL)
      return -1;
    socket_tab = new_tab;
    socket_tab_capacity++;
  }
  if (socket_arr_cached == NULL) {
    socket_arr_cached = new_socket_array();
    if (socket_arr_cached == NULL)
      return -1;
  }
  socket_tab[socket_tab_size++] = socket_arr_cached;
  socket_arr_cached = NULL;
  return (int) ((socket_tab_size - 1)*SOCKET_ARRAY_SIZE);
}

static int close_socket_fd(unsigned fd)
{
  int r = 0;
  size_t row = fd/SOCKET_ARRAY_SIZE;
  size_t idx = fd%SOCKET_ARRAY_SIZE;
  SOCKET s = (*socket_tab[row])[idx];
  size_t dup_row;

  /* check if socket is not dup'ed */
  for (dup_row = 0; dup_row < socket_tab_size; dup_row++) {
    size_t dup_idx;
    for (dup_idx = 0; dup_idx < SOCKET_ARRAY_SIZE; dup_idx++) {
      if ((*socket_tab[dup_row])[dup_idx] == s &&
          (dup_row != row || dup_idx != idx))
        goto found_dup;
    }
  }
found_dup:

  /* don't close if socket was dup'ed */
  if (dup_row == socket_tab_size)
    r = closesocket(s);

  (*socket_tab[row])[idx] = INVALID_SOCKET;
  if (row != socket_tab_size - 1 || dup_row == row)
    return r;

  /* try to free tail rows */
  for (;; row--) {
    size_t j = 0;
    for (; j < SOCKET_ARRAY_SIZE; j++) {
      if ((*socket_tab[row])[j] != INVALID_SOCKET)
        return r;
    }
    if (socket_arr_cached != NULL)
      free(socket_arr_cached);
    socket_arr_cached = socket_tab[row];
    socket_tab_size = row;
    if (socket_tab_size == 0)
      return r;
  }
}

static SOCKET *get_socket(unsigned fd)
{
  size_t row = fd/SOCKET_ARRAY_SIZE;
  size_t idx = fd%SOCKET_ARRAY_SIZE;
  return &(*socket_tab[row])[idx];
}

static void free_socket_tab(void)
{
  /* all FDs must be closed */
  assert(socket_tab_size == 0);
  if (socket_arr_cached != NULL) {
    free(socket_arr_cached);
    socket_arr_cached = NULL;
  }
  if (socket_tab != NULL) {
    free(socket_tab);
    socket_tab = NULL;
  }
  socket_tab_capacity = 0;
}

int ws_socket_dup(int oldfd)
{
  assert(is_socket(oldfd));
  {
    int fd = alloc_socket_fd();
    if (fd != -1) {
      SOCKET s = *get_socket((unsigned)oldfd & ~SOCKET_FD_BIT);
      *get_socket((unsigned)fd) = s;
      return (int)(fd | SOCKET_FD_BIT);
    }
    return INVALID_HANDLE;
  }
}

#ifndef SOCKET_FILE_BUFFER_SIZE
#define SOCKET_FILE_BUFFER_SIZE 4096
#endif

socket_file_t *socket_file_alloc(void)
{
  struct socket_file *sf = (struct socket_file*) malloc(sizeof(*sf));
  if (sf != NULL) {
    sf->buf = malloc(SOCKET_FILE_BUFFER_SIZE);
    if (sf->buf != NULL) {
      sf->buf_size = SOCKET_FILE_BUFFER_SIZE;
      sf->filled = 0;
      return sf;
    }
    free(sf);
  }
  return NULL;
}

void socket_file_free(socket_file_t *sf)
{
  free(sf->buf);
  free(sf);
}

int socket_file_fflush(socket_file_t *sf, fd_t fd)
{
  int ret;
  SOCKET s;
  if (sf->filled == 0)
    return 0;
  if (sf->filled < 0) {
    errno = EIO;
    return EOF;
  }
  s = *get_socket(fd & ~SOCKET_FD_BIT);
  ret = send(s, (const char*) sf->buf, sf->filled, 0);
  if (ret == SOCKET_ERROR) {
    errno = EIO;
    sf->filled = 0 - sf->filled - 1;
    return EOF;
  }
  sf->filled = 0;
  return 0;
}

size_t socket_file_fwrite(socket_file_t *sf, fd_t fd,
  const void *ptr, size_t size, size_t nmemb)
{
  int ret;
  SOCKET s;
  size_t n, result, to_send, rem;
  unsigned space;
  if (nmemb == 0 || size == 0 || sf->filled < 0)
    return 0;
  s = *get_socket(fd & ~SOCKET_FD_BIT);
  n = nmemb;
  space = sf->buf_size - sf->filled;
  if (size == 1) {
    to_send = n;
    if (to_send > space) {
      n = to_send - space;
      to_send = space;
    }
    rem = 0;
  }
  else {
    to_send = size;
    while (--n && to_send < space)
      to_send += size;
    if (to_send > space) {
      rem = to_send - space;
      to_send = space;
    }
    else
      rem = 0;
  }
  if (sf->filled || (unsigned) to_send != space) {
    char *dest = (char*) sf->buf + sf->filled;
    unsigned filled = (unsigned) (((char*) memcpy(dest, ptr, to_send)
      - (char*) sf->buf) + (unsigned) to_send);
    if (filled != sf->buf_size) {
      sf->filled = (int) filled;
      return nmemb;
    }
    ptr = (const char*) ptr + (unsigned) to_send;
    ret = send(s, (const char*) sf->buf, (int) filled, 0);
    if (ret == SOCKET_ERROR) {
      errno = EIO;
      sf->filled = 0 - (int) (filled - (unsigned) (size - rem)) - 1;
      return nmemb - n - 1;
    }
    space = (unsigned) filled;
    goto block_sent;
  }
  for (result = 0;;) {
    ret = send(s, (const char*) ptr, (int) space, 0);
    if (ret == SOCKET_ERROR) {
      errno = EIO;
      sf->filled = -1;
      return result;
    }
    ptr = (const char*) ptr + space;
block_sent:
    result = nmemb - n - !!rem;
    if (size == 1) {
      to_send = n;
      if (to_send > space) {
        n = to_send - space;
        to_send = space;
      }
      else if (to_send != space)
        break;
    }
    else {
      for (to_send = rem; n && to_send < space; n--)
        to_send += size;
      if (to_send > space) {
        rem = to_send - space;
        to_send = space;
      }
      else if (to_send != space)
        break;
      else
        rem = 0;
    }
  }
  sf->filled = (int) to_send;
  if (to_send)
    memcpy(sf->buf, ptr, to_send);
  return nmemb;
}

void socket_file_clearerr(socket_file_t *sf)
{
  if (sf->filled < 0)
    sf->filled = 0 - (sf->filled + 1);
}

int os_fstat(int fd, gawk_stat_t *buf)
{
  if (!is_socket(fd))
    return _fstat64(fd, buf);
  else {
    memset(buf, 0, sizeof(*buf));
    buf->st_mode = S_IFSOCK;
    buf->st_dev = (dev_t)-1;
    return 0;
  }
}

int os_xfstat(int fd, gawk_xstat_t *buf)
{
  if (!is_socket(fd))
    return xfstat((void*) _get_osfhandle(fd), NULL, buf);
  else {
    memset(buf, 0, sizeof(*buf));
    buf->st_mode = S_IFSOCK;
    buf->st_dev = (xdev_t)-1;
    return 0;
  }
}

#endif /* _MSC_VER */

SOCKET
fd_to_socket(int fd)
{
#ifndef _MSC_VER
  if (fd != INVALID_HANDLE)
    return _get_osfhandle(fd);
#else /* _MSC_VER */
  if (is_socket(fd))
    return *get_socket(fd & ~SOCKET_FD_BIT);
#endif /* _MSC_VER */
  return INVALID_SOCKET;
}

int
socket_to_fd(SOCKET s)
{
  if (s == INVALID_SOCKET)
    return INVALID_HANDLE;
#ifndef _MSC_VER
  return _open_osfhandle ((intptr_t)s, O_BINARY | O_NOINHERIT);
#else /* _MSC_VER */
  {
    int fd = alloc_socket_fd();
    if (fd != -1) {
      *get_socket((unsigned)fd) = s;
      return (int)(fd | SOCKET_FD_BIT);
    }
    return INVALID_HANDLE;
  }
#endif /* _MSC_VER */
}

int
w32_socket(int family, int type, int protocol)
{
  /* We need to use WSASocket rather than socket, since the latter
     creates overlapped sockets that cannot be used in file I/O
     APIs.  */
  SOCKET s = WSASocket (family, type, protocol, NULL, 0, 0);

  if (s == INVALID_SOCKET)
    {
      switch (WSAGetLastError ())
	{
	  case WSAEMFILE:
	    errno = EMFILE;
	    break;
	  case WSANOTINITIALISED:
	  case WSAENETDOWN:
	    errno = EACCES;
	    break;
	  case WSAENOBUFS:
	    errno = ENOMEM;
	    break;
	  case WSAEFAULT:
	    errno = EFAULT;
	    break;
	  default:
	    errno = EINVAL;
	    break;
	}
    }

  return socket_to_fd (s);
}

int
w32_setsockopt (int fd, int level, int optname, const char *optval, int optlen)
{
  SOCKET s = FD_TO_SOCKET (fd);

  return setsockopt (s, level, optname, optval, optlen);
}

int
w32_bind (int fd, const struct sockaddr *name, int namelen)
{
  SOCKET s = FD_TO_SOCKET (fd);

  return bind (s, name, namelen);
}

int
w32_connect (int fd, const struct sockaddr *name, int namelen)
{
  SOCKET s = FD_TO_SOCKET (fd);

  return connect (s, name, namelen);
}

int
w32_listen (int fd, int backlog)
{
  SOCKET s = FD_TO_SOCKET (fd);

  return listen (s, backlog);
}

int
w32_accept (int fd, struct sockaddr *addr, int *addrlen)
{
  SOCKET s = FD_TO_SOCKET (fd);

  return socket_to_fd (accept (s, addr, addrlen));
}

SOCKET
valid_socket (int fd)
{
  SOCKET s = FD_TO_SOCKET (fd);
  if (s == INVALID_SOCKET)
    return INVALID_SOCKET;

#ifndef _MSC_VER
  {
    int ov, ol = 4;
    if (getsockopt (s, SOL_SOCKET, SO_TYPE, (char *)&ov, &ol) == SOCKET_ERROR
        && WSAGetLastError() == WSAENOTSOCK)
      s = INVALID_SOCKET;
  }
#endif

  return s;
}

int
w32_closemaybesocket (int fd)
{
  int res;

#ifdef _MSC_VER

  if (is_socket (fd)) {
    int res2 = close_socket_fd (fd & ~SOCKET_FD_BIT);
    res = res2 == SOCKET_ERROR ? -1 : 0;
  }
  else
    res = close (fd);

#else /* !_MSC_VER */

  SOCKET s = valid_socket (fd);
  res = close (fd);
  if (s != INVALID_SOCKET) {
    int res2 = closesocket (s);
    if (res2 == SOCKET_ERROR)
      res = -1;
  }

#endif /* !_MSC_VER */

  return res;
}

int
w32_recvfrom (int fd, char *buf, int len, int flags,
	      struct sockaddr *from, int *fromlen)
{
  SOCKET s = FD_TO_SOCKET (fd);

  return recvfrom (s, buf, len, flags, from, fromlen);
}

int
w32_shutdown (int fd, int how)
{
  SOCKET s = FD_TO_SOCKET (fd);

  return shutdown (s, how);
}

const char *
gai_strerror_buf (int ecode, char buf[], unsigned int buf_size)
{
  DWORD ret;

  ret = FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM
		       | FORMAT_MESSAGE_IGNORE_INSERTS,
		       NULL, (DWORD) ecode, 0, buf, buf_size, NULL);
  while (ret > 0 && (buf[ret - 1] == '\n' || buf[ret - 1] == '\r'))
    --ret;

  buf[ret] = '\0';
  if (!ret)
    {
      (void) _snprintf (buf, buf_size, "Error code %d", ecode);
      buf[buf_size - 1] = '\0';
    }

  return buf;
}

#endif	/* HAVE_SOCKETS */

/* Translate abnormal exit status of Windows programs into the signal
   that terminated the program.  This is required to support scm_kill
   and WTERMSIG.  */

#include <signal.h>

struct signal_and_status {
  int sig;
  unsigned status;
};

static const struct signal_and_status sigtbl[] = {
  {SIGSEGV, 0xC0000005},	/* access to invalid address */
  {SIGSEGV, 0xC0000008},	/* invalid handle */
  {SIGILL,  0xC000001D},	/* illegal instruction */
  {SIGILL,  0xC0000025},	/* non-continuable instruction */
  {SIGSEGV, 0xC000008C},	/* array bounds exceeded */
  {SIGFPE,  0xC000008D},	/* float denormal */
  {SIGFPE,  0xC000008E},	/* float divide by zero */
  {SIGFPE,  0xC000008F},	/* float inexact */
  {SIGFPE,  0xC0000090},	/* float invalid operation */
  {SIGFPE,  0xC0000091},	/* float overflow */
  {SIGFPE,  0xC0000092},	/* float stack check */
  {SIGFPE,  0xC0000093},	/* float underflow */
  {SIGFPE,  0xC0000094},	/* integer divide by zero */
  {SIGFPE,  0xC0000095},	/* integer overflow */
  {SIGILL,  0xC0000096},	/* privileged instruction */
  {SIGSEGV, 0xC00000FD},	/* stack overflow */
  {SIGTERM, 0xC000013A},	/* Ctrl-C exit */
  {SIGINT,  0xC000013A}
};

int
w32_status_to_termsig (unsigned status)
{
  unsigned i;

  for (i = 0; i < sizeof (sigtbl) / sizeof (sigtbl[0]); i++)
    if (status == sigtbl[i].status)
      return sigtbl[i].sig;

  return SIGTERM;
}

void
w32_maybe_set_errno (void)
{
  DWORD w32err = GetLastError ();

  switch (w32err)
    {
      /* When stdout is redirected to a pipe, and the program that
	 reads the pipe (e.g., a pager) exits, Windows doesn't set
	 errno to a useful value.  Help it DTRT.  */
      case ERROR_BAD_PIPE:
      case ERROR_PIPE_BUSY:
      case ERROR_NO_DATA:
      case ERROR_PIPE_NOT_CONNECTED:
	errno = EPIPE;
	break;
      default:
	errno = EINVAL;
	break;
    }
}

#endif	/* __MINGW32__ || _MSC_VER */

#if defined(__DJGPP__) || defined(__MINGW32__) || defined(__EMX__) || defined(_MSC_VER)

void
init_sockets(void)
{
#if defined(HAVE_SOCKETS) && !defined(__EMX__)
  WSADATA  winsockData;
  int errcode;

  if ((errcode = WSAStartup (0x101, &winsockData)) != 0
      || winsockData.wVersion != 0x101)
    fatal(_("cannot start Winsock (%d)"), errcode);
#endif
}

#endif	/* __DJGPP__ || __MINGW32__ || __EMX__ || _MSC_VER */

#ifdef __DJGPP__

/* Replacement for the missing nl_langinfo.  DJGPP provides only C locale.  */
#include <langinfo.h>

const char *
nl_langinfo (int item)
{
  switch (item)
    {
      case CODESET:
      default:
        return "";
    }
}


# if __DJGPP__ == 2 && __DJGPP_MINOR__ < 4 
int
unsetenv (const char *name)
{
  if (!name || !*name || strchr (name, '=') != NULL)
    return -1;

  return putenv (name);
}
#endif

/* This is needed to defeat too-clever GCC warnings in dfa.c about
   comparison being always false due to limited range of data type.  */
wint_t
btowc (int c)
{
  return c;
}

wint_t
putwc(wchar_t wc, FILE *stream)
{
  return MB_CUR_MAX == 1 && wc > 0 && wc <= UCHAR_MAX
         && putc((unsigned char)wc, stream) != EOF ? (wint_t)wc : WEOF;
}

#endif /* __DJGPP__ */


#ifdef _MSC_VER

/* Array of multibyte program args converted from Unicode.  */
static char **gawk_argv = NULL;

/* Convert program arguments from wide-char to multibyte
  according to the locale codepage.  */
char **
convert_wargv(int argc, wchar_t **wargv)
{
	wchar_t **wa = wargv;
	char **argv;

	/* Note: argv array must be NULL-terminated.  */
	emalloc(argv, char **, sizeof(*argv) * (argc + 1), "convert_wargv");

	for (; *wa; wa++) {
		const size_t need = wcstombs(NULL, *wa, 0);

		if ((size_t) -1 == need)
			fatal(_("failed to convert argument %u (Unicode -> LC_CTYPE=%s): %s"),
				(unsigned)(wa - wargv), setlocale(LC_CTYPE, NULL), strerror(errno));

		{
			char *a;
			emalloc(a, char *, need + 1, "convert_wargv");

			wcstombs(a, *wa, need + 1);
			argv[wa - wargv] = a;
		}
	}

	/* argv - is a NULL-terminated array of pointers */
	argv[wa - wargv] = NULL;

	return (gawk_argv = argv);
}

/* Free arguments array allocated by convert_wargv().
  This is called from final_exit().  */
void
gawk_free_argv(void)
{
	if (gawk_argv) {
		char **a = gawk_argv;
		for (; *a; a++)
			efree(*a);
		efree(gawk_argv);
	}
	free_socket_tab();
}

#endif /* _MSC_VER */
